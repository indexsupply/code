// View functions and log parsing from npmanager.json
//
// Code generated by "genabi"; DO NOT EDIT.
package npmanager

import (
	"bytes"
	"github.com/indexsupply/x/abi"
	"github.com/indexsupply/x/abi/schema"
	"github.com/indexsupply/x/e2pg"
)

type DAODeployedEvent struct {
	item     *abi.Item
	Token    [20]byte
	Metadata [20]byte
	Auction  [20]byte
	Treasury [20]byte
	Governor [20]byte
}

func (x DAODeployedEvent) Done() {
	x.item.Done()
}

func DecodeDAODeployedEvent(item *abi.Item) DAODeployedEvent {
	x := DAODeployedEvent{}
	x.item = item
	x.Token = item.At(0).Address()
	x.Metadata = item.At(1).Address()
	x.Auction = item.At(2).Address()
	x.Treasury = item.At(3).Address()
	x.Governor = item.At(4).Address()
	return x
}

func (x DAODeployedEvent) Encode() *abi.Item {
	items := make([]*abi.Item, 5)
	items[0] = abi.Address(x.Token)
	items[1] = abi.Address(x.Metadata)
	items[2] = abi.Address(x.Auction)
	items[3] = abi.Address(x.Treasury)
	items[4] = abi.Address(x.Governor)
	return abi.Tuple(items...)
}

var (
	// Pre-compute for efficient bloom filter checks
	DAODeployedSignatureHash = []byte{0x1, 0xe2, 0xc4, 0xf2, 0xec, 0xa5, 0xca, 0x81, 0x7, 0xe0, 0x17, 0x51, 0xab, 0x15, 0x3f, 0xfe, 0x3b, 0x16, 0x2d, 0xd6, 0x5c, 0xac, 0x25, 0xbf, 0xa5, 0xd1, 0x3c, 0x1, 0x7c, 0x19, 0x6d, 0x9d}
	DAODeployedSignature     = []byte{0x45, 0x6d, 0x2b, 0xaf, 0x5a, 0x87, 0xd7, 0xe, 0x58, 0x6e, 0xc0, 0x6f, 0xb9, 0x1c, 0x2d, 0x78, 0x49, 0x77, 0x8d, 0xd4, 0x1d, 0x80, 0xfa, 0x82, 0x6a, 0x6e, 0xa5, 0xbf, 0x8d, 0x28, 0xe3, 0xa6}
	DAODeployedSchema        = schema.Parse("(address,address,address,address,address)")
	DAODeployedNumIndexed    = int(0)
)

// Event Signature:
//	DAODeployed(address,address,address,address,address)
// Checks the first log topic against the signature hash:
//	456d2baf5a87d70e586ec06fb91c2d7849778dd41d80fa826a6ea5bf8d28e3a6
//
// Copies indexed event inputs from the remaining topics
// into [DAODeployed]
//
// Uses the the following abi schema to decode the un-indexed
// event inputs from the log's data field into [DAODeployed]:
//	(address,address,address,address,address)
func MatchDAODeployed(l *e2pg.Log) (DAODeployedEvent, error) {
	if l.Topics.Len() <= 0 {
		return DAODeployedEvent{}, abi.NoTopics
	}
	if !bytes.Equal(DAODeployedSignature, l.Topics.At(0)) {
		return DAODeployedEvent{}, abi.SigMismatch
	}
	if l.Topics.Len()-1 != DAODeployedNumIndexed {
		return DAODeployedEvent{}, abi.IndexMismatch
	}
	item, _, err := abi.Decode(l.Data, DAODeployedSchema)
	if err != nil {
		return DAODeployedEvent{}, err
	}
	res := DecodeDAODeployedEvent(item)
	return res, nil
}

type UpgradeRegisteredEvent struct {
	item        *abi.Item
	BaseImpl    [20]byte
	UpgradeImpl [20]byte
}

func (x UpgradeRegisteredEvent) Done() {
	x.item.Done()
}

func DecodeUpgradeRegisteredEvent(item *abi.Item) UpgradeRegisteredEvent {
	x := UpgradeRegisteredEvent{}
	x.item = item
	x.BaseImpl = item.At(0).Address()
	x.UpgradeImpl = item.At(1).Address()
	return x
}

func (x UpgradeRegisteredEvent) Encode() *abi.Item {
	items := make([]*abi.Item, 2)
	items[0] = abi.Address(x.BaseImpl)
	items[1] = abi.Address(x.UpgradeImpl)
	return abi.Tuple(items...)
}

var (
	// Pre-compute for efficient bloom filter checks
	UpgradeRegisteredSignatureHash = []byte{0xf2, 0x4b, 0xa5, 0x50, 0x6b, 0xb5, 0x81, 0xac, 0xe9, 0x64, 0xff, 0x96, 0x89, 0xfe, 0xc9, 0x76, 0x36, 0x1b, 0x3b, 0xf, 0x8a, 0xf7, 0xec, 0xee, 0xd0, 0xb0, 0xff, 0x93, 0x15, 0x1, 0xc8, 0x44}
	UpgradeRegisteredSignature     = []byte{0xab, 0x6a, 0x7d, 0xc5, 0x47, 0x21, 0xd6, 0xa1, 0xa2, 0x84, 0xca, 0x86, 0x58, 0x30, 0xf8, 0x98, 0x1d, 0x6f, 0x12, 0xfb, 0xdd, 0xb3, 0x61, 0x8d, 0x17, 0x74, 0xb7, 0x1c, 0x0, 0x36, 0x80, 0x59}
	UpgradeRegisteredSchema        = schema.Parse("(address,address)")
	UpgradeRegisteredNumIndexed    = int(0)
)

// Event Signature:
//	UpgradeRegistered(address,address)
// Checks the first log topic against the signature hash:
//	ab6a7dc54721d6a1a284ca865830f8981d6f12fbddb3618d1774b71c00368059
//
// Copies indexed event inputs from the remaining topics
// into [UpgradeRegistered]
//
// Uses the the following abi schema to decode the un-indexed
// event inputs from the log's data field into [UpgradeRegistered]:
//	(address,address)
func MatchUpgradeRegistered(l *e2pg.Log) (UpgradeRegisteredEvent, error) {
	if l.Topics.Len() <= 0 {
		return UpgradeRegisteredEvent{}, abi.NoTopics
	}
	if !bytes.Equal(UpgradeRegisteredSignature, l.Topics.At(0)) {
		return UpgradeRegisteredEvent{}, abi.SigMismatch
	}
	if l.Topics.Len()-1 != UpgradeRegisteredNumIndexed {
		return UpgradeRegisteredEvent{}, abi.IndexMismatch
	}
	item, _, err := abi.Decode(l.Data, UpgradeRegisteredSchema)
	if err != nil {
		return UpgradeRegisteredEvent{}, err
	}
	res := DecodeUpgradeRegisteredEvent(item)
	return res, nil
}

type UpgradeRemovedEvent struct {
	item        *abi.Item
	BaseImpl    [20]byte
	UpgradeImpl [20]byte
}

func (x UpgradeRemovedEvent) Done() {
	x.item.Done()
}

func DecodeUpgradeRemovedEvent(item *abi.Item) UpgradeRemovedEvent {
	x := UpgradeRemovedEvent{}
	x.item = item
	x.BaseImpl = item.At(0).Address()
	x.UpgradeImpl = item.At(1).Address()
	return x
}

func (x UpgradeRemovedEvent) Encode() *abi.Item {
	items := make([]*abi.Item, 2)
	items[0] = abi.Address(x.BaseImpl)
	items[1] = abi.Address(x.UpgradeImpl)
	return abi.Tuple(items...)
}

var (
	// Pre-compute for efficient bloom filter checks
	UpgradeRemovedSignatureHash = []byte{0x69, 0x69, 0x35, 0xd6, 0x7c, 0xc, 0x3f, 0x96, 0x60, 0x11, 0x77, 0x55, 0xc2, 0xf6, 0x30, 0xab, 0x7, 0xed, 0x9d, 0xf, 0x53, 0x6, 0xd6, 0x1a, 0xa2, 0x91, 0x37, 0x55, 0x7d, 0x8c, 0xcb, 0x9a}
	UpgradeRemovedSignature     = []byte{0xe, 0xbd, 0x98, 0xf6, 0xf7, 0x5e, 0x38, 0xba, 0x2f, 0x7, 0x51, 0x37, 0x8f, 0x5c, 0x86, 0x20, 0x5c, 0xaf, 0xca, 0x83, 0xe2, 0x6, 0xcb, 0x62, 0x79, 0x5f, 0x45, 0xfc, 0xea, 0x72, 0x83, 0x33}
	UpgradeRemovedSchema        = schema.Parse("(address,address)")
	UpgradeRemovedNumIndexed    = int(0)
)

// Event Signature:
//	UpgradeRemoved(address,address)
// Checks the first log topic against the signature hash:
//	0ebd98f6f75e38ba2f0751378f5c86205cafca83e206cb62795f45fcea728333
//
// Copies indexed event inputs from the remaining topics
// into [UpgradeRemoved]
//
// Uses the the following abi schema to decode the un-indexed
// event inputs from the log's data field into [UpgradeRemoved]:
//	(address,address)
func MatchUpgradeRemoved(l *e2pg.Log) (UpgradeRemovedEvent, error) {
	if l.Topics.Len() <= 0 {
		return UpgradeRemovedEvent{}, abi.NoTopics
	}
	if !bytes.Equal(UpgradeRemovedSignature, l.Topics.At(0)) {
		return UpgradeRemovedEvent{}, abi.SigMismatch
	}
	if l.Topics.Len()-1 != UpgradeRemovedNumIndexed {
		return UpgradeRemovedEvent{}, abi.IndexMismatch
	}
	item, _, err := abi.Decode(l.Data, UpgradeRemovedSchema)
	if err != nil {
		return UpgradeRemovedEvent{}, err
	}
	res := DecodeUpgradeRemovedEvent(item)
	return res, nil
}
