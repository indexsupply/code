package abi

import (
	"bytes"
	"crypto/rand"
	"encoding/hex"
	"fmt"
	"reflect"
	"testing"

	"github.com/indexsupply/x/abi/at"
)

func TestPad(t *testing.T) {
	r := []byte{0x20}
	rwant := make([]byte, 32)
	rwant[0] = 0x20
	if !bytes.Equal(rpad(r), rwant) {
		t.Errorf("want: %x got: %x", rwant, rpad(r))
	}

	b := make([]byte, 33)
	rand.Read(b[:])
	bwant := make([]byte, 64)
	copy(bwant, b)
	if !bytes.Equal(bwant, rpad(b)) {
		t.Errorf("want: %x got: %x", bwant, rpad(b))
	}
}

// Test vector taken from:
// https://docs.soliditylang.org/en/latest/abi-spec.html#examples
func TestEncode(t *testing.T) {
	want, _ := hex.DecodeString(`0000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000a0000000000000000000000000000000000000000000000000000000000000000464617665000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000003000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000003`)
	got := Encode(Tuple(String("dave"), Bool(true), List(Int(1), Int(2), Int(3))))
	if !bytes.Equal(want, got) {
		t.Errorf("want: %x got: %x", want, got)
	}
}

// Test vector taken from:
// https://docs.soliditylang.org/en/latest/abi-spec.html#use-of-dynamic-types
func TestEncode_Nested(t *testing.T) {
	want, _ := hex.DecodeString(`000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000001400000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000a0000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000030000000000000000000000000000000000000000000000000000000000000003000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000e000000000000000000000000000000000000000000000000000000000000000036f6e650000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000374776f000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000057468726565000000000000000000000000000000000000000000000000000000`)
	got := Encode(Tuple(
		List(List(Int(1), Int(2)), List(Int(3))),
		List(String("one"), String("two"), String("three")),
	))
	if !bytes.Equal(want, got) {
		t.Errorf("want: %x got: %x", want, got)
	}
}

func TestDecode(t *testing.T) {
	want := Tuple(List(List(Int(1), Int(2)), List(Int(3))))
	got := Decode(Encode(want), at.Tuple(at.List(at.List(at.Int))))
	if !reflect.DeepEqual(want, got) {
		t.Errorf("want: %# v got: %# v", want, got)
	}
}

func TestDecode_Tuple(t *testing.T) {
	want := Encode(
		Tuple(
			String("satoshi"),
			Int(2008),
			Tuple(
				String("vitalik"),
				List(Int(2008), Int(2010)),
			),
		),
	)
	got := Decode(want, at.Tuple(
		at.String,
		at.Int,
		at.Tuple(
			at.String,
			at.List(at.Int),
		),
	))
	if got.At(0).String() != "satoshi" {
		t.Errorf("want: satoshi got: %q", got.At(0).String())
	}
	if got.At(1).Int() != 2008 {
		t.Errorf("want: 2008 got: %d", got.At(1).Int())
	}
	if got.At(2).At(1).At(0).Int() != 2008 {
		t.Errorf("want: 2008 got: %d", got.At(2).At(1).At(0).Int())
	}
}

func debug2(b []byte) []byte {
	out := fmt.Sprintf("len: %d\n", len(b))
	for i := 0; i < len(b); i += 32 {
		out += fmt.Sprintf("%x\n", b[i:i+32])
	}
	fmt.Printf("debug2:\n%s\n", out)
	return b
}
func debug(t *testing.T, b []byte) []byte {
	t.Helper()
	out := fmt.Sprintf("len: %d\n", len(b))
	for i := 0; i < len(b); i += 32 {
		out += fmt.Sprintf("%x\n", b[i:i+32])
	}
	t.Logf("debug:\n%s\n", out)
	return b
}
