{{ define "package" }}
// Code generated by "genabi"; DO NOT EDIT.

package {{ . }}
{{ end }}

{{ define "imports" }}
import (
	{{ range . -}}
	"{{ . }}"
	{{ end -}}
)
{{ end }}

{{ define "get-struct" -}}
func (x *{{ .Struct }}){{ .Method }}() *{{ .Method }} {
	i := x.it.At({{ .Index }})
	return &{{ .Method }}{&i}
}
{{ range $i, $c := .Input.Components -}}
	{{ template "getter" getter $i $.Event $c -}}
{{ end }}
{{ end -}}

{{ define "get-list-nested" -}}
it{{ .Index }} := it{{ sub .Index 1 }}.At(i{{ sub .Index 1 }})
res{{ .Index }} := make({{ .Type.TemplateSig }}, it{{ .Index }}.Len())
for i{{ .Index }} := 0; i{{ .Index }} < it{{ .Index }}.Len(); i{{ .Index }}++ {
	{{ with .Next -}}
		{{ template "get-list-nested" . }}
	{{ else -}}
        res{{ .Index }}[i{{ .Index }}] = it{{ .Index }}.At(i{{ .Index }}).{{ .Type.Elem.TemplateFunc }}()
    {{ end -}}
}
res{{ sub .Index 1}}[i{{ sub .Index 1}}] = res{{ .Index }}
{{- end -}}

{{ define "get-list" -}}
func (x *{{ .Struct}}){{ .Method }}() {{ .Type.TemplateSig }} {
	it0 := x.it.At({{ .Index }})
	{{ if eq .Type.Length 0 -}}
		res0 := make({{ .Type.TemplateSig }}, it0.Len())
	{{ else }}
		if it0.Len() != {{ .Type.Length }} {
			panic("genabi: {{ .Struct }}.{{ .Method }} array size mismatch")
		}
		var res0 {{ .Type.TemplateSig }}
	{{ end -}}
	for i0 := 0; i0 < it0.Len(); i0++ {
		{{ if gt .Type.Dimension 1 -}}
			{{ template "get-list-nested" ngetter . }}
        {{ else -}}
            res0[i0] = it0.At(i0).{{ .Type.Elem.TemplateFunc }}()
        {{ end -}}
    }
    return res0
}
{{ end -}}

{{ define "get" -}}
func (x *{{ .Struct}}){{ .Method }}() {{ .Type.TemplateType }}{
	return x.it.At({{ .Index }}).{{ .Type.TemplateFunc }}()
}
{{ end -}}

{{ define "getter" }}
	{{ if eq .Type.Kind 2 -}}
		{{ template "get-struct" . -}}
	{{ else if eq .Type.Kind 3 -}}
		{{ template "get-list" . -}}
	{{ else  -}}
		{{ template "get" . -}}
	{{ end -}}
{{ end }}

{{- define "input" -}}
	abi.Input{
		{{ if eq .Indexed true -}}
		Indexed: true,
		{{ end -}}
		Name: "{{.Name}}",
		Type: "{{.Type}}",
		{{ if eq .Type "tuple" -}}
		Components: []abi.Input{
		{{ range .Components -}}
		{{ template "input" . }}
		{{ end }}
		},
		{{ end }}
	},
{{- end -}}

{{ define "structs" -}}
	{{ range $inp := . -}}
		{{ if eq .Type "tuple" }}
			type {{camel .Name }} struct {
				it *abi.Item
			}
			{{ template "structs" $inp.Components -}}
		{{ end -}}
	{{ end -}}
{{ end -}}

{{- define "event" -}}
	var {{ camel .Name }}Event = abi.Event{
		Name: "{{ .Name }}",
		Inputs: []abi.Input{
			{{ range .Inputs -}}
			{{ template "input" . }}
			{{ end }}
		},
	}

	type {{ camel .Name }} struct {
		it *abi.Item
	}

	func Match{{ camel .Name }}(l abi.Log) (*{{ camel .Name }}, bool) {
		i, ok := abi.Match(l, {{ camel .Name }}Event)
		return &{{ camel .Name }}{&i}, ok
	}

	{{ template "structs" .Inputs -}}

	{{ $event := . }}
	{{ range $i, $input := .Inputs -}}
		{{ template "getter" getter $i $event $input -}}
	{{ end -}}
{{ end -}}
